#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define M 3  //定义行数
#define N 3  //定义列数
///便于对角线计算此处行列数相同

//随机生成二维数组
//按行排列二维数组
//按列排列二维数组
//周边/对角线/素数/完全平方数计算


//二维数组示例-主要熟悉冒泡算法
//不懂原理的自行将代码熟记下来.  by run 2021-04-28
//下面我们以“3  2  4  1”为例对冒泡排序进行说明。
//
//第一轮  排序过程
//3  2  4  1    （最初）
//2  3  4  1    （比较3和2，交换）
//2  3  4  1    （比较3和4，不交换）
//2  3  1  4    （比较4和1，交换）
//第一轮结束，最大的数字 4 已经在最后面，因此第二轮排序只需要对前面三个数进行比较。
//
//第二轮  排序过程
//2  3  1  4 （第一轮排序结果）
//2  3  1  4 （比较2和3，不交换）
//2  1  3  4 （比较3和1，交换）
//第二轮结束，次大的数字 3 已经排在倒数第二个位置，所以第三轮只需要比较前两个元素。
//
//第三轮  排序过程
//2  1  3  4  （第二轮排序结果）
//1  2  3  4  （比较2和1，交换）
//
//至此，排序结束。
void main123()
{
	///////////////////////////随机生成一个二维数组,并赋值/////////////////////
	printf("随机生成的二维数组：\n");
	srand(time(0));//种子,确保生成的不一样
	int a[M][N], t = 0;
	for (int i = 0; i < M; i++)
	{
		for (int j = 0; j < N; j++)
		{
			int x = rand() % 10;
			a[i][j] = x;
			printf("%3d", x);
		}
		printf("\n");
	}
	//////////////////////////////////////END///////////////////////////////

	/////////////////////////////按行排序//////////////////////////////////
	printf("按行排列后的二维数组：\n");
	for (int i = 0; i < M; i++)//循环行
	{
		for (int j = 0; j < N - 1; j++)
		{
			for (int k = 0; k < N -j-1; k++)
			{
				if (a[i][k] > a[i][k + 1])
				{
					t = a[i][k];
					a[i][k] = a[i][k + 1];
					a[i][k + 1] = t;
				}
			}
		}
	}
	for (int i = 0; i < M; i++)
	{
		for (int j = 0; j < N; j++)
		{
			printf("%3d", a[i][j]);
		}
		printf("\n");
	}
	///////////////////////////////END///////////////////////////////////////

	/////////////////////////////按列排序///////////////////////////////////
	printf("按列排列后的二维数组：\n");
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			for (int k = M - 1; k > j; k--)
				if (a[k][i] < a[j][i])
				{
					t = a[k][i];
					a[k][i] = a[j][i];
					a[j][i] = t;
				}
		}
	}
	for (int i = 0; i < M; i++)
	{
		for (int j = 0; j < N; j++)
		{
			printf("%3d", a[i][j]);
		}
		printf("\n");
	}
	////////////////////////////////END/////////////////////////////////////

	int round = round_sum(a);
	printf("周边元素之和: %d\n", round);

	int djx = djx_sum(a);
	printf("对角线之和: %d\n", djx);

	int ss = sushu_count(a); 
	printf("素数总个数是: %d\n", ss);

	int Square = Square_count(a);
	printf("完全平方数总个数是: %d\n", Square);

}

/// <summary>
/// 计算二维数组周边长之和
/// </summary>
/// <param name="a"></param>
/// <returns></returns>
////////////////////////////////周边长之和计算///////////////////////////////////
	//这个是矩阵周边所有数据的和。例如3 * 3的矩阵，周边的数据就有第1行、第3行的第2列到最后，第1列的第二行到第2行的1个，第3列的第2行最后一个到第2行的最后一个。

	//	例如以下示意图：

	//	1	1	1
	//	1	 	1
	//	1	1	1

//////////////////////////////////////////////////////////////////////////
int round_sum(int a[M][N])
{
	int s = 0;
	for (int i = 0; i < N; i++)//循环列,获取第一行与最后一行的和
	{
		s += a[0][i] + a[M-1][i];//第一行与最后一行的和
	}
	for (int j = 0; j < M-2; j++)//循环列,获取除第一行与最后一行的边的和
	{
		s += a[j+1][0] + a[j + 1][N-1];
	}
	return s;
}

/// <summary>
/// 计算对角线之和
/// </summary>
/// <param name="a"></param>
/// <returns></returns>
//对角线有两条对角线，分两种情况，一种是N* N矩阵的N为偶数，另一种是N为奇数，在偶数的时候，两条对角线没有相重复的数值，而为奇数的时候有一个交叉的数值重复，则需要再减一个交叉的数值。
//
//例如：4 * 4矩阵N为偶数的矩阵示意图：对角线没有交叉的数据
//
//1	 	 	 1
//    1	 1
// 	  1	 1
//1	 	 	 1
//例如：3 * 3矩阵N为奇数的矩阵示意图：对角线有交叉的数据
//
//1	 	1
//   1
//1	 	1
//
//————————————————
int djx_sum(int a[N][N])
{
	int  s = 0;
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)
		{
			if (i == j)
			{
				s += a[i][j];
			}
		}
		s += a[i][N - i - 1];
	}
	if (N % 2 == 1)//如果矩阵为偶数,则减去交叉的数字
	{
		s -= a[N / 2][N / 2];
	}
	return s;
}

////判断素数
//判断一个整数m是否是素数，只需把 m 被 2 ~ m-1 之间的每一个整数去除，如果都不能被整除，那么 m 就是一个素数。
int  sushu_count(int a[M][N])
{
	int count = 0;
	int sum = 0;
	for (int i = 0; i < M; i++)
	{
		for (int j = 0; j < N; j++)
		{
			count = 0;
			if (a[i][j] <2) //如果是<2 直接跳过,不是素数.
			{
				continue;
			}
			//if (a[i][j] == 2) //如果是2 直接是素数 ,+1;
			//{
			//	sum++;
			//	continue;
			//}
			for (int k = 2; k < a[i][j]; k++)
			{
				if (a[i][j] % k == 0) {//如果整除就+1;
					count++; 
					break;
				}

			}
			if (count == 0)//等于0说明都没有被2整除
			sum++;
		}
	}
	return sum;
}

////判断完全平方数
//判断完全平方数总个数
int  Square_count(int a[M][N])
{
	int count = 0;
	for (int i = 0; i < M; i++)
	{
		for (int j = 0; j < N; j++)
		{
			for (int k = 0; k <= a[i][j]; k++)
			{
				if (k*k == a[i][j]) {
					count++; 
					break;
					
				}

			}
		}
	}
	return count;
}